üîπ What is GLSL?
GLSL (OpenGL Shading Language) is a C-like programming language used to write shaders, which run directly on the GPU for high-performance rendering. It is used in WebGL, Three.js, Unity, Unreal Engine, and many other real-time graphics applications.

üîπ What Are Shaders?
Shaders are small programs that run in parallel on the GPU to handle visual effects. There are two main types in WebGL: 1Ô∏è‚É£ Vertex Shader ‚Äì Handles object transformations, positions, and effects at the vertex level.
2Ô∏è‚É£ Fragment Shader (Pixel Shader) ‚Äì Handles colors, textures, and pixel effects.
‚úÖ Bonus Shaders: Geometry Shaders, Tessellation Shaders, Compute Shaders (Advanced)


1Ô∏è‚É£ Vectors & Scalars in GLSL

üìå What are Scalars?
A scalar is a single value (number). It can be an int, float or bool.
Scalars are the building blocks of vectors.


üìå What are Vectors?
A vector stores a multiple values together, GLSL provides:
vec2 (2D vector) ‚Üí (x, y)
vec3 (3D vector) ‚Üí (x, y, z)
vec4 (4D vector) ‚Üí (x, y, z, w)

 Declaring Vectors
vec2 position = vec2(1.0, 2.0); // x = 1.0, y = 2.0
vec3 color = vec3(1.0, 0.0, 0.0); // Red color (RGB)
vec4 vertex = vec4(0.5, 0.2, 0.8, 1.0); // RGBA (with aplha)

 Understanding vec2, vec3, and vec4
What is vec2?
vec2 is used when working with 2D positions, movement, or texture coordinates.
It has two components: x and y.
Example: vec2 position = vec2(0.5, 0.3); // x = 0.5, y = 0.3
Where is this used?
Moving objects in 2D space (screen position).
Texture mapping (UV coordinates).

What is vec3?
vec3 is NOT just for colors‚Äîit is for anything that has 3 values.
Colors (RGB): vec3 color = vec3(1.0, 0.0, 0.0); // Red color (R = 1, G = 0, B = 0)
3D positions (x, y, z): vec3 position = vec3(1.0, 2.0, 3.0); // (x=1, y=2, z=3)

What is vec4?
vec4 is used for anything with 4 components.
It is mostly used for colors with alpha (RGBA) and 3D positions with a fourth "w" coordinate.
RGBA Colors: vec4 color = vec4(1.0, 0.5, 0.2, 0.8); // R=1.0, G=0.5, B=0.2, A=0.8
A (alpha) controls transparency.
0.0 = Fully transparent, 1.0 = Fully visible.
Homogeneous 3D Position (w = 1.0)
vec4 position = vec4(1.0, 2.0, 3.0, 1.0);
The w component is used in 3D transformations.

 üí°Summary
Type	Components	Used For
vec2	(x, y)	2D movement, UV textures
vec3	(x, y, z)	3D positions, colors (RGB), normals
vec4	(x, y, z, w)	RGBA colors, homogeneous coordinates

 Global Variables vs Function Variables
In GLSL, global variables are declared outside of functions.
‚ùå This does NOT work: vec3 myVector = vec3(3.0, 4.0, 5.0); // ‚ùå ERROR
Why?
GLSL requires global variables to be constant.
Why constant? Because shaders work in parallel (each pixel runs separately).
But vec3(3.0, 4.0, 5.0) is computed dynamically, so it cannot be global.
‚úÖ Solution: Use const for Global Variables
const vec3 myVector = vec3(3.0, 4.0, 5.0); // ‚úÖ Constant value
‚úÖ Solution: Move it Inside a Function
void main() {
    vec3 myVector = vec3(3.0, 4.0, 5.0); // ‚úÖ Works inside function
}

 Why Do We Use void for main()?
In GLSL, every shader must have a main() function, and it does not return any value.
void means "this function doesn‚Äôt return anything".

 What is the Difference Between Dot Product and Cross Product?
Dot Product (vec1 = vec2 ‚Ä¢ vec3)
‚úÖ Used to find angles and lighting calculations.
‚úÖ Gives a single number (scalar).
‚úÖ Formula:  A . B = (Ax x Bx) + (Ay x By) + (Az x Bz);
Example:
vec3 A = vec3(1.0, 2.0, 3.0);
vec3 B = vec3(4.0, 5.0, 6.0);
float dotResult = dot(A, B); // = (1*4) + (2*5) + (3*6) = 32
What is it used for?
Find angle between two vectors.
Calculate brightness (lighting in 3D).
üåü Imagine This in Real Life
Example 1: Your Hands
Hold out your right hand in front of you.
Point your index finger forward (Vector A).
Point your middle finger to the right (Vector B).
Now, stick out your thumb.
‚úÖ Your thumb is pointing UP ‚Üí This is the cross product of your fingers!
Direction	Vector
Index Finger (Forward)	Vector A (x-axis)
Middle Finger (Right)	Vector B (y-axis)
Thumb (Up)	Cross Product (z-axis)
üöÄ This is why the cross product always gives a perpendicular (90¬∞) vector!
vec3 A = vec3(1, 0, 0); // Right (x-axis)
vec3 B = vec3(0, 1, 0); // Up (y-axis)
vec3 C = cross(A, B);   // (0, 0, 1) ‚Üí Forward (z-axis)
‚úÖ The result (0, 0, 1) means the new vector points forward (Z-axis)!
The cross product is used when you have two directions (or two positions), and you want to find the third perpendicular direction that completes a right-angle system (like X, Y, and Z in 3D space).
Key Takeaways
Takes two vectors	                          You provide two known directions.
Finds the missing perpendicular vector	    It calculates the third direction.
Only works in 3D (vec3)	                    It doesn‚Äôt work in 2D (vec2).
Useful in	                                  Lighting, normals, physics, 3D rotations.

 Final Summary
Concept	Explanation
vec2	2D movement, UV textures
vec3	3D positions, RGB colors
vec4	RGBA colors, 3D transformations
Global Variable Error	Needs constant values (const)
void main()	No return values, must set gl_FragColor
Dot Product	Angle between vectors, lighting
Cross Product	Finds perpendicular vector (normals)
